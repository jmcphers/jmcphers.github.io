<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Lessons from 20 Years of Development</title><link rel=stylesheet type=text/css href=https://jmcphers.github.io//css/emm386.css></head><body><div class=container><h1>Lessons from 20 Years of Development</h1><p>I&rsquo;ve been writing software professionally for most of the last two decades. In this time I&rsquo;ve worked just about everywhere: on government contracts, at healthcare companies, in universities, at very big companies (more than 100K employees) and very small ones (fewer than 10 employees). I&rsquo;ve written clients, servers, web applications, utilities, plugins, and frameworks.</p><p>Here are some of the things I&rsquo;ve learned over those twenty years. They&rsquo;re my opinions, but they&rsquo;ve served me well.</p><p><strong>Don&rsquo;t use state, and make state immutable wherever possible.</strong> Immutable state is not an unalloyed good. Used thoughtlessly, it leads to very inefficient programs. However, like static typing, it eliminates a large class of bugs. Many bugs are caused by the program entering an unexpected state; these are not only common but difficult to reproduce as &ldquo;how did this value (state) get into memory&rdquo; is a difficult question to answer, even if you&rsquo;re good with data breakpoints. In contrast, software engineering approaches which use less state sometimes make finding the source of the invalid state as easy as walking the callstack.</p><p><strong>Don&rsquo;t optimize prematurely.</strong> In school, and in interviews, we&rsquo;re all taught to think very hard about the big-O complexity of our algorithms, for it&rsquo;s often the case that the one-off program you wrote to handle 10 items (for which an N^2 algorithm only costs 100) now needs to handle 10,000 (for which it now costs 10,000,000). However, in most real-world applications, inefficiencies are only rarely due to poorly written algorithms. They are more often due to architectural decisions, such as marshaling data between too many layers, using heavyweight components to do simple jobs, and the like. It&rsquo;s so difficult to know for sure where your performance problems lie that it&rsquo;s usually best to get the system working in its simplest form and then using a profiler to figure out where the actual performance problems lie.</p><p><strong>Use statically typed languages.</strong> It is sometimes faster, and sometimes easier, to code without type information. However, statically typed languages push an entire class of bugs from runtime (where my users see them) to compile time (where I see them). This is invaluable. Statically typed languages also tremendously improve the development experience by allowing for the use of refactoring tools and improving autocompletion/intellisense (as the editor itself knows what you can do with an object of a known type). It is for this reason that I&rsquo;m a big fan of projects like <a href=https://www.typescriptlang.org/>TypeScript</a>.</p><p><strong>Be declarative, not imperative.</strong> It&rsquo;s easier to screw up instructions than information. If you can encode a problem as an algorithm acting on data instead of a more complicated algorithm, you&rsquo;ll rarely regret it.</p><p><strong>Code for the maintainer.</strong> Some people leave copious comments. Some people think they can write self-documenting code. I think they&rsquo;re wrong, but that&rsquo;s another story. No matter which way you slice it, though, code with an eye towards making the maintainer&rsquo;s life easy. Code is read much more often than it is written. Code simply. Don&rsquo;t lay traps. Keep state local so that it&rsquo;s obvious what will be affect when code changes. That maintainer you&rsquo;re coding for is probably yourself.</p><p><strong>Keep modules small and loosely coupled.</strong> You&rsquo;d think this would go without saying, but it doesn&rsquo;t. Complexity will kill you. You can only handle so much of it, so split it into smaller pieces until your brain can understand each piece. If you&rsquo;re me, those pieces are pretty small.</p><p><strong>Think first, code later</strong>. Just twenty minutes sketching out the outline of what I&rsquo;m doing helps me think about what I&rsquo;m building end-to-end. If I can&rsquo;t at least walk through how it&rsquo;s going to work in my head, I don&rsquo;t often start coding, because I&rsquo;m liable to waste time going down dead ends.</p><p><strong>Start coding as soon as you can</strong>. Some people plan in a very detailed way before they start coding. I&rsquo;m of the opinion that this is often a waste of time. At a sufficiently low level of detail, you may as well be coding. Once you have a rough picture of the system in your head and have the major technical decisions made, there is no substitute for actually writing code. It&rsquo;s often easier to let your code tell you what you need to get the system working than it is to guess exhaustively ahead of time.</p><p><strong>Be simple, not clever.</strong> An engineer wiser than myself (Brian Kernigham) once said:</p><blockquote><p>Everyone knows that debugging is twice as hard as writing a program in the first place. So if you&rsquo;re as clever as you can be when you write it, how will you ever debug it?</p></blockquote><p>Having authored several clever systems which later turned out to be nightmarish to debug, I&rsquo;ve found this advice rings true. Use simple mechanisms you understand thoroughly. If you must use a new mechanism, or invent one, make sure you&rsquo;re choosing the simplest one for the job.</p><p><strong>Self-test ruthlessly.</strong> An unfortunate truth: you know your system too well to test it correctly. Your users, or your QA team if you have one, are going to use your software in ways you did not anticipate or think about. This, however, does not absolve you of the responsibility to ruthlessly test your own work as best you can before you let it out in the wild; in fact, while your status as the system&rsquo;s designer gives you some testing blind spots, it also gives you some insight your QA team and users will never have about where the true edge cases lie. Be pessimistic. Try to put yourself in your users&rsquo; shoes. Develop a reputation for delivering software that works the first time.</p><p><strong>Invest in good tools.</strong> It amazes me how many engineers use substandard tooling to develop software when the world is teeming with powerful, extensible editors and IDEs. They all have strengths and weaknesses; the important thing is to pick one and ruthlessly configure it until it does exactly what you need. My editor of choice is Vim, but there are dozens of others that can be great if you just give them a little time and attention. At a minimum, your editor should highlight your syntax, offer auto-completion of properties and methods, and give you warnings about improper syntax and usage without requiring a compile pass.</p><p><strong>Learn makefile syntax.</strong> GNU Make is a remarkably powerful tool, and you can use it to automate the generation of <em>almost anything</em> from <em>almost anything else</em>, in a declarative way. Once mastered, it can efficiently produce websites, documents, and all manner of other deliverables. It works with any command you can execute at a shell. It&rsquo;s an essential part of a reproducible workflow.</p><p><strong>Use plain text files and tools.</strong> Plain text is the <em>lingua franca</em> of the software engineer. It can be consumed by decades-old tools and will be readable decades from now. Plain text can be version controlled, and takes up little space. It&rsquo;s human-readable. It&rsquo;s easy to copy, paste, format, share, and remix. You won&rsquo;t regret having data in plain text.</p><p><strong>Write tests, but not religiously.</strong> Tests are valuable. They can give you great confidence when making changes, and reduce the risk of regressions. They are also a wonderful forcing function: writing a test for your code forces you to think about it thoroughly and critically. However, tests also increase the cost of changes to your code, because you must also write and change tests. I&rsquo;ve seen buggy, slow software with plenty of tests, and fast, accurate software with almost none. Tests are not a silver bullet, and the easiest tests to write are often the least useful. Use them, but use them cautiously.</p><p><strong>First, make it work end-to-end.</strong> There are lots of difficult decisions and complicated pieces in most software projects. It&rsquo;s very easy to get distracted by one of these before your software does anything useful, and to continue to be distracted because it&rsquo;s easier to focus on a small, known problem than tackle a large, unknown one. However, until your software does <em>something</em>, until it works end-to-end for its simplest use case, there&rsquo;s a good chance there&rsquo;s something big you haven&rsquo;t thought of yet. Get it working before you worry about the details.</p><p><strong>Learn constantly.</strong> Nowhere is the old adage &ldquo;Change is the only constant&rdquo; more true than in software engineering. Software engineers are in the unique position of being the primary fashioners of their own tools, and boy, do they make a lot of them. New platforms, paradigms, systems, and languages spring up every few weeks. Spend some time learning about these and playing with them if you have time, but don&rsquo;t make the mistake of thinking that just because it&rsquo;s new means it&rsquo;s better; many new things fizzle, whereas old things have by definition stood the test of time.</p><p><strong>Add a new tool to your personal toolkit.</strong> Every now and again, think about the way you work. Could something be better? Are you, for instance, spending a lot of time switching among lots of terminal windows? Or is managing time and tasks difficult for you? Or are you continually frustrated by your mail program? All of these problems, and many more, have dozens of clever software solutions you probably haven&rsquo;t have heard of but could easily find with some web searching. Regularly evaluate your personal toolkit with a critical eye and add new tools to it. If there&rsquo;s nothing you can solve with off the shelf software, what about writing a script of your own? (Some developers have the opposite problem, in which we obsess over our personal toolkit at the expense of actually building stuff with it. I certainly don&rsquo;t know any developers like <em>that</em>.)</p><p><strong>Always think about the end goal.</strong> Solving technical problems is so much fun for most of us that we often forget to think about whether they are worth solving. The relationship between the technical difficulty of a problem and the value of solving it is almost non-existent. Always ask yourself whether what you&rsquo;re doing is going to make a big difference to someone using your software. Work on the things that matter to your users.</p><p><strong>Know when to buy and when to build.</strong> Whichever one you choose, it will be more expensive than you thought, and not as good. Choose wisely.</p><p>Of course, this is all about the act of engineering itself &ndash; which is only a small portion of your job as a software engineer. I hope, however, that it&rsquo;s helpful.</p><p class=footer>copyright &copy; 2022 Jonathan McPherson</p></div></body></html>